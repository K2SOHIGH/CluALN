import pandas as pd
import os
import yaml
import sys
import glob
import multiprocessing

from scripts import snakeutils as su

"""
    dependencies :
        - mmseqs
    input [required] :
        - fasta file 
        - output directory path
    input [optional] :
        - old_fasta : previous fasta file used for clustering
        - old_seqdb : -
        - old_cludb : -
        - coverage : - 
        - clumode : - 
        - verbose : [0..3]
    output:
        - config["res_dir"]/cluDB.tsv
        - config["res_dir"]/cluDB
        - config["res_dir"]/seqDB
"""

TARGET = [os.path.join(config['res_dir'],'clustering','clu.done')]
if config ["per_clu_msa"]:
    """
        each cluster will be aligned and pairwise identity will be compute
    """
    TARGET.append(
        os.path.join(config['res_dir'],'per_clu_msa.done')
    )


if config ["merge"]:    
    """
        each cluster will be aligned and pairwise identity will be compute AND msaS will be merged.
    """
    TARGET += [
        os.path.join(config['res_dir'],'merged','merge.done'),
        os.path.join(config['res_dir'],'per_clu_msa.done'),
    ]
    
rule all:
    output:
        os.path.join(config['res_dir'],'summary.txt')
    input:  
        TARGET,
    params:
        resdir = config["res_dir"],
    script:
        os.path.join('scripts','summary.py')

rule merge_target:
    output:
        touch(temp(os.path.join(config['res_dir'],'merged','merge.done')))
    input:
        os.path.join(config['res_dir'],'per_clu_msa.done'),
        os.path.join(config['res_dir'],'clustering','clu.done'),
        os.path.join(config["res_dir"],"merged","tables","identity.tsv"),
        os.path.join(config["res_dir"],"merged","tables","similarity.tsv"),
        os.path.join(config["res_dir"],"merged","tables","summary.tsv"),


def aggregate_cluster_id(wildcards):
    import glob
    checkpoint_output = checkpoints.cluster2fasta.get(**wildcards).output[0]
    clusters = [os.path.basename(i) for i in glob.glob(os.path.join(checkpoint_output, "cluster_*" ))]
    idt = expand(os.path.join(config["res_dir"],"per_cluster","{cluster}","tables","identity.tsv"),
        cluster = clusters)
    sim = expand(os.path.join(config["res_dir"],"per_cluster","{cluster}","tables","similarity.tsv"),
        cluster = clusters)
    su = expand(os.path.join(config["res_dir"],"per_cluster","{cluster}","tables","summary.tsv"),
        cluster = clusters)
    return idt + sim + su



rule per_cluster_target:
    output:
        touch(temp(os.path.join(config['res_dir'],'per_clu_msa.done')))
    input:        
        os.path.join(config['res_dir'],'clustering','clu.done'),
        aggregate_cluster_id,

rule clustering_target:
    output:
        touch(temp(os.path.join(config['res_dir'],'clustering','clu.done')))
    input:
        expand(os.path.join(config["res_dir"],"{target}","tables","clusters.tsv"),target="clustering"),
        expand(os.path.join(config["res_dir"],"{target}","tables","consensus_length.tsv"),target="clustering"),
        expand(os.path.join(config["res_dir"],"{target}","tables","identity.tsv"),target="clustering"),
        expand(os.path.join(config["res_dir"],"{target}","tables","similarity.tsv"),target="clustering"),
        expand(os.path.join(config["res_dir"],"{target}","tables","summary.tsv"),target="clustering"),


def get_input_idt(wildcards):
    if wildcards.which == "all":
        return os.path.join(config["res_dir"],"{fasta}","alignements","clusters.msa.aln"),
    return os.path.join(config["res_dir"],"{fasta}","fastas","representatives.aln.fasta")


rule identity_matrix:
    output:
        os.path.join(config["res_dir"],"{target}","tables","identity.tsv"),
        os.path.join(config["res_dir"],"{target}","tables","similarity.tsv"),
        os.path.join(config["res_dir"],"{target}","tables","summary.tsv"),
    input:
        msa = os.path.join(config["res_dir"],"{target}","alignements","msa.aln")
    params:
        matrix = workflow.source_path("../resources/BLOSUM62.txt"),
        outdir = os.path.join(config["res_dir"],"{target}","tables"),
        distance = True,
    script:
        os.path.join('scripts','get_identity_matrix.py')


# MSA
rule cluster_msa2msa:
    output:
        os.path.join(config["res_dir"],"merged","alignements","msa.aln")
    input:
        msas = os.path.join(config["res_dir"],"merged",'input_msa'),
        tbl = os.path.join(config["res_dir"],"merged",'tbl_msa'),
    params:
        outdir = os.path.join(config["res_dir"],"merged","alignements"),
    conda:
        os.path.join("envs","mafft.yaml")
    threads:
        10 #multiprocessing.cpu_count()
    shell:
        'mkdir -p {params.outdir} ; '
        'if [[ $(cat {input.tbl} | grep -c "#") == 1 ]] ; then '
        '   cat {input.msas} > {output};'
        'else '
        '   mafft --thread {threads} --anysymbol --maxiterate 100 --merge {input.tbl} {input.msas} > {output};'
        'fi'

def aggregate_cluster(wildcards):
    import glob
    checkpoint_output = checkpoints.cluster2fasta.get(**wildcards).output[0]
    clusters = [os.path.basename(i) for i in glob.glob(os.path.join(checkpoint_output, "cluster_*" ))]
    return expand(os.path.join(config["res_dir"],"per_cluster","{cluster}","alignements","msa.aln"),
        cluster = clusters)

rule mafft_merge_input:
    output:
        msas = os.path.join(config["res_dir"],"merged",'input_msa'),
        tbl = os.path.join(config["res_dir"],"merged",'tbl_msa'),
    input:
        aggregate_cluster,
    script:
        os.path.join("scripts",'makemergeinput.py')

rule mafft:
    output:
        os.path.join(config["res_dir"],"{target}","alignements","msa.aln"), 
    input:
        os.path.join(config["res_dir"],"{target}","fastas","seq.fasta"),  
    conda:
        os.path.join("envs","mafft.yaml")
    threads:
        10 
    shell:
        "mafft --thread {threads} --anysymbol --quiet {input} > {output}"

checkpoint cluster2fasta:
    output:
        directory(os.path.join(config["res_dir"],"per_cluster")),
    input:
        clu = os.path.join(config["res_dir"],"clustering","tables","clusters.tsv"),
        fa = os.path.join(config["res_dir"],"clustering","fastas","input.fasta"),
    conda:
        os.path.join("envs","biopy.yaml")
    script:
        os.path.join("scripts",'clu2fasta.py')

# CLUSTERING
rule get_consensus_length:
    output:
        os.path.join(config["res_dir"],"clustering","tables","consensus_length.tsv")
    input:
        os.path.join(config["res_dir"],"clustering","fastas","consensus.fa"),
    conda:
        os.path.join("envs","biopy.yaml")
    script:
        os.path.join('scripts','get_length.py')

rule profiles2consensus:
    output:
        fasta = temp(os.path.join(config["res_dir"],"clustering","fastas","consensus.fa"))
    input:
        os.path.join(config["res_dir"],"clustering","profilDB","clu2profile.done")
    params:
        consensusDB = os.path.join(config["res_dir"],"clustering","profilDB","consensusDB"),
        proDB = os.path.join(config["res_dir"],"clustering","profilDB","proDB"),
        verbose = config["verbose"],
    conda:
        os.path.join("envs","mmseqs_13.45.yaml")
    shell:
        "mmseqs profile2consensus {params.proDB} {params.consensusDB} -v {params.verbose}  && "
        "mmseqs convert2fasta {params.consensusDB} {output.fasta} -v {params.verbose}"



rule cluster2profiles: 
    output:
        os.path.join(config["res_dir"],"clustering","profilDB","clu2profile.done"),
    input:
        os.path.join(config["res_dir"],"clustering","tables","clusters.tsv"),
    params:
        outdir = os.path.join(config["res_dir"],"clustering","profilDB"),
        seqDB = os.path.join(config["res_dir"],"clustering","clusterDB","seqDB"),        
        cluDB = os.path.join(config["res_dir"],"clustering","clusterDB","cluDB"),   
        verbose = config["verbose"],
    conda:
        os.path.join("envs","mmseqs_13.45.yaml")
    shell:
        "mkdir -p {params.outdir} && "
        "mmseqs result2profile {params.seqDB} {params.seqDB} {params.cluDB} {params.outdir}/proDB -v {params.verbose} && touch {output}  "


rule representative2fasta:
    output:
        os.path.join(config["res_dir"],"clustering","fastas","seq.fasta"),    
    input:
        os.path.join(config["res_dir"],"clustering","tables","clusters.tsv"),
    params:
        tmp = os.path.join(config["res_dir"],"clustering","clusterDB",'tmp'),
        seqDB = os.path.join(config["res_dir"],"clustering","clusterDB","seqDB"),        
        cluDB = os.path.join(config["res_dir"],"clustering","clusterDB","cluDB"),    
        verbose=config["verbose"],
    conda:
        os.path.join("envs","mmseqs_13.45.yaml")
    shell:
        "mmseqs createsubdb {params.cluDB} {params.seqDB} {params.cluDB}.rep ;"
        "mmseqs convert2fasta {params.cluDB}.rep {output}" 



rule cluster2tsv:
    output:
        os.path.join(config["res_dir"],"clustering","tables","clusters.tsv"),    
    input:
        os.path.join(config["res_dir"],"clustering","clustering.done"),
    params:
        tbldir = os.path.join(config["res_dir"],"clustering","tables"),
        tmp = os.path.join(config["res_dir"],"clustering","clusterDB",'tmp'),
        seqDB = os.path.join(config["res_dir"],"clustering","clusterDB","seqDB"),        
        cluDB = os.path.join(config["res_dir"],"clustering","clusterDB","cluDB"),    
        verbose=config["verbose"],
    conda:
        os.path.join("envs","mmseqs_13.45.yaml")
    shell:
        "mkdir -p {params.tbldir} && "
        "mmseqs createtsv {params.seqDB} {params.seqDB} {params.cluDB} "
        "{output} -v {params.verbose}"


rule clustering:
    output:
        os.path.join(config["res_dir"],"clustering","clustering.done"),
        #produce <config["res_dir"]>/cluDB
    input:
        os.path.join(config["res_dir"],"clustering","createdb.done")
    conda:
        os.path.join("envs","mmseqs_13.45.yaml")   
    params:
        seqDB = os.path.join(config["res_dir"],"clustering","clusterDB","seqDB"),
        cluDB = os.path.join(config["res_dir"],"clustering","clusterDB","cluDB"), #output
        tmp = os.path.join(config["res_dir"],"clustering","clusterDB",'tmp'),
        clumode = config["clumode"],
        coverage = config["coverage"],
        covmode = config["covmode"],
        pid = config["pid"],
        verbose=config["verbose"]
    shell:
        "mmseqs cluster {params.seqDB} {params.cluDB} {params.tmp} "
        "--cluster-mode {params.clumode} "
        "--min-seq-id {params.pid} "
        "--cov-mode {params.covmode} "
        "-c {params.coverage} "
        "-v {params.verbose}  && echo success > {output}"


rule create_db:
    output:
        os.path.join(config["res_dir"],"clustering","createdb.done"),
    input:
        os.path.join(config["res_dir"],"clustering","fastas","input.fasta")
    params:
        out = os.path.join(config["res_dir"],"clustering","clusterDB"),
        tmp = os.path.join(config["res_dir"],"clustering","clusterDB",'tmp'),
        verbose = config["verbose"],
    conda:
        os.path.join("envs","mmseqs_13.45.yaml")     
    shell:
        "mkdir -p {params.tmp} && "
        "mmseqs createdb {input[0]} {params.out}/seqDB -v {params.verbose} &&"
        "echo success > {output} 2> {output}"


rule gunzip_cds:
    output:
        os.path.join(config["res_dir"],"clustering","fastas","input.fasta"),
    input:
        config['clu_input'] ,
    shell:        
        'if [[ {input} == *.gz ]] ; then '
        'gunzip -c {input} ; '
        'else '
        'cat {input} ; '        
        'fi > {output} '
